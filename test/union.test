BEGIN Untagged union definition
union { int x; int y; } z;
EXPECT_AST
[["var", "ES", ["UNION", [["x", "Si"], ["y", "Si"]]], "z"]]


BEGIN Tagged union definition
union S { int x; int y; } z;
EXPECT_AST
[["var", "ES", ["UNION", [["x", "Si"], ["y", "Si"]]], "z"]]
EXPECT_GLOBALS
[["typedef",["UNION",[["x","Si"],["y","Si"]]],"S"]
,["var","ES",["UNION",[["x","Si"],["y","Si"]]],"z"]]


BEGIN Union member names must be distinct
union U { int x; int x; };
DECLARATIONS
EXPECT_MESSAGE
:1:22: error duplicate member 'x'
EXPECT_GLOBALS
[["typedef",["UNION",[["x","Si"]]],"U"]]


BEGIN Tagged incomplete union
union S z;
EXPECT_AST
[["var","ES",["UNION",["?"]],"z"]]
EXPECT_GLOBALS
[["typedef",["UNION",["?"]],"S"]
,["var","ES",["UNION",["?"]],"z"]]


BEGIN Tagged union with multiple compatible definitions
union S { int x; int y; };
union S { int x; int y; };
EXPECT_GLOBALS
[["typedef",["UNION",[["x","Si"],["y","Si"]]],"S"]]


BEGIN Order of members does not matter for compatible unions
union S { int y; int x; };
union S { int x; int y; };
DECLARATIONS
EXPECT_GLOBALS
[["typedef",["UNION",[["y","Si"],["x","Si"]]],"S"]]


BEGIN Complete union must contain all members of compatible union
union S { int x; };
union S { float x; };
DECLARATIONS
EXPECT_MESSAGE
:2:1: error redefinition of 'S' with different type
:1:1: see other definition
EXPECT_GLOBALS
[["typedef",["UNION",[["x","Si"]]],"S"]]


BEGIN Complete union compatible with incomplete union (1)
union S;
union S { int x; int y; };
EXPECT_GLOBALS
[["typedef",["UNION",[["x","Si"],["y","Si"]]],"S"]]


BEGIN Complete union compatible with incomplete union (2)
union S { int x; int y; };
union S;
DECLARATIONS
EXPECT_GLOBALS
[["typedef",["UNION",[["x","Si"],["y","Si"]]],"S"]]


BEGIN Partially complete unions not allowed
union S { int x; ... };
DECLARATIONS
EXPECT_MESSAGE
:1:18: error unexpected token '...'
EXPECT_GLOBALS
[["typedef",["UNION",[["x","Si"]]],"S"]]