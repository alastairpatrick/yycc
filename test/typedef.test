BEGIN Variable declaration of typedef type (declarations).
typedef short foo_t;
foo_t foo;
DECLARATIONS
EXPECT_AST
[["typedef", "Ss", "foo_t"]
,["var", "ES", "Ss", "foo"]]


BEGIN Variable declaration of typedef type (preparse).
foo_t foo;
typedef short foo_t;
PREPARSE
EXPECT_AST
[["var", "ES", "Nfoo_t", "foo"]
,["typedef", "Ss", "foo_t"]]


BEGIN Typedef with no declarators
typedef;
EXPECT_MESSAGE
:1:1: error invalid type specifier combination
EXPECT_AST
[[]]


BEGIN Pointer typedef
typedef float T;
typedef T* P;
P x;
DECLARATIONS
EXPECT_GLOBALS
[["typedef",["P","Ff"],"P"],["typedef","Ff","T"],["var","ES",["P","Ff"],"x"]]


BEGIN Array typedef
typedef float T;
typedef T A[1];
A x;
DECLARATIONS
EXPECT_GLOBALS
[["typedef",["A","Ff",1],"A"],["typedef","Ff","T"],["var","ES",["A","Ff",1],"x"]]


BEGIN Qualified typedef
typedef float T;
typedef const T U;
U x;
DECLARATIONS
EXPECT_GLOBALS
[["typedef","Ff","T"],["typedef",["Qc","Ff"],"U"],["var","ES",["Qc","Ff"],"x"]]


BEGIN Function typedef
typedef float T;
typedef T F(T);
F f;
DECLARATIONS
EXPECT_GLOBALS
[["typedef",["F","Ff","Ff"],"F"],["typedef","Ff","T"],["fun","E",["F","Ff","Ff"],"f"]]


BEGIN Typedef in block scope
typedef int a;
void f(void) {
    typedef long a;
}
DECLARATIONS
EXPECT_AST
[
    ["typedef", "Si", "a"],
    ["fun","E",["F", "V"],"f",[""], ["block", [
        ["typedef", "Sl", "a"]]
    ]]
]


BEGIN Disambiguates between multiplication and variable declaration of pointer type
int p, q;
void f(void) {
    q * p; // "q" is not a type so this is multiplication.
    typedef short q;
    q * v; // now "q" is a type so this declares variable "v" with type "q*".
}
DECLARATIONS
EXPECT_AST
[
    [["var", "ES", "Si", "p"],
     ["var", "ES", "Si", "q"]],
    ["fun","E",["F", "V"],"f",[""], ["block", [
        ["*", "Nq", "Np"],
        ["typedef", "Ss", "q"],
        ["var", "", ["P", "Ss"], "v"]
    ]]]
]


BEGIN Typedef goes out of scope immediately following block
void f(void) {
    int p, q;
    {
        typedef long q;
    }
    q * p; // Identifier "q" immediately follows '}'
}
DECLARATIONS
EXPECT_AST
[["fun","E",["F", "V"],"f",[""], ["block", [
    [["var", "", "Si", "p"],
     ["var", "", "Si", "q"]],
    ["block", [
        ["typedef", "Sl", "q"]
    ]],
    ["*", "Nq", "Np"]
]]]]


BEGIN Typedef may not be used as a variable.
typedef long p;
void f(void) {
    p+p;
}
DECLARATIONS
EXPECT_MESSAGE
:3:6: error expected identifier but got '+'
EXPECT_AST
[["typedef","Sl","p"],["fun","E",["F", "V"],"f",[""],["block",[[]]]]]


BEGIN Typedef may not be inline
inline typedef int A;
EXPECT_MESSAGE
:1:20: error 'inline' may only appear on function
EXPECT_AST
[["typedef", "Si", "A"]]


BEGIN Struct typedef
typedef struct { int x; int y; } z;
EXPECT_AST
[["typedef", ["STRUCT", [["x", "Si"], ["y", "Si"]]], "z"]]


BEGIN Error on typedef with bit-field
typedef int T: 2;
EXPECT_MESSAGE
:1:14: error expected ';' but got ':'
EXPECT_AST
[["typedef", "Si", "T"]]


BEGIN Typedef of type declared in other translation unit
typedef T S;
PREPARSE
EXPECT_AST
[["typedef", "NT", "S"]]


BEGIN cyclic #type directive with no accompanying type definition
#type T
DECLARATIONS
EXPECT_MESSAGE
:1:7: error 'T' undeclared
EXPECT_GLOBALS
[["typedef","Si","T"]]


BEGIN Non-trivial recursive typedefs are an error (1)
#type T
typedef T T[];
DECLARATIONS
EXPECT_MESSAGE
:2:11: error recursive definition of 'T'
EXPECT_GLOBALS
[["typedef","Si","T"]]


BEGIN  Non-trivial recursive typedefs are an error (2)
#type T
typedef T T[];
typedef int T[];
DECLARATIONS
EXPECT_MESSAGE
:2:11: error recursive definition of 'T'
EXPECT_GLOBALS
[["typedef",["A","Si"],"T"]]


BEGIN  Non-trivial recursive typedefs are an error (3)
#type T
typedef int T[];
typedef T T[];
DECLARATIONS
EXPECT_MESSAGE
:3:11: error recursive definition of 'T'
EXPECT_GLOBALS
[["typedef",["A","Si"],"T"]]


BEGIN Trivial recursive typedefs are an error if not accompanied by non-recursive definition
#type T
typedef T T;
DECLARATIONS
EXPECT_MESSAGE
:2:11: error 'T' undeclared
EXPECT_GLOBALS
[["typedef","Si","T"]]


BEGIN #type resolves ambiguity as to whether identifier is type or not
#type T
void f(void) {
    T * v; // "T" is a type so this declares variable "v" with type "T*".
}
typedef float T;
DECLARATIONS
EXPECT_GLOBALS
[
    ["typedef","Ff","T"],
    ["fun","E",["F","V"],"f",[""],
        ["block",[
            ["var","",["P","Ff"],"v"]
        ]]
    ]
]


BEGIN Error on use of type name as an expression
typedef int T;
char a[T];
DECLARATIONS
EXPECT_MESSAGE
:2:8: error identifier is not an expression
EXPECT_GLOBALS
[["typedef","Si","T"],["var","ES",["A","C",1],"a"]]

