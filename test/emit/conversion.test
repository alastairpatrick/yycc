BEGIN Integer signedness only conversion
unsigned f(int x) {
    return x;
}
EXPECT_IR
define i32 @f(i32 %0) {
entry:
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %1 = load i32, ptr %x, align 4
  ret i32 %1
}
END


BEGIN Integer zero extending conversion
unsigned f(unsigned short x) {
    return x;
}
EXPECT_IR
define i32 @f(i16 %0) {
entry:
  %x = alloca i16, align 2
  store i16 %0, ptr %x, align 2
  %1 = load i16, ptr %x, align 2
  %2 = zext i16 %1 to i32
  ret i32 %2
}
END


BEGIN Integer sign extending conversion
int f(short x) {
    return x;
}
EXPECT_IR
define i32 @f(i16 %0) {
entry:
  %x = alloca i16, align 2
  store i16 %0, ptr %x, align 2
  %1 = load i16, ptr %x, align 2
  %2 = sext i16 %1 to i32
  ret i32 %2
}
END


BEGIN Integer truncating conversion
short f(int x) {
    return x;
}
EXPECT_IR
define i16 @f(i32 %0) {
entry:
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %1 = load i32, ptr %x, align 4
  %2 = trunc i32 %1 to i16
  ret i16 %2
}
END


BEGIN Floating point extending conversion
double f(float x) {
    return x;
}
EXPECT_IR
define double @f(float %0) {
entry:
  %x = alloca float, align 4
  store float %0, ptr %x, align 4
  %1 = load float, ptr %x, align 4
  %2 = fpext float %1 to double
  ret double %2
}
END


BEGIN Floating point truncating conversion
float f(double x) {
    return x;
}
EXPECT_IR
define float @f(double %0) {
entry:
  %x = alloca double, align 8
  store double %0, ptr %x, align 8
  %1 = load double, ptr %x, align 8
  %2 = fptrunc double %1 to float
  ret float %2
}
END


BEGIN Signed integer to floating point conversion
float f(int x) {
    return x;
}
EXPECT_IR
define float @f(i32 %0) {
entry:
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %1 = load i32, ptr %x, align 4
  %2 = sitofp i32 %1 to float
  ret float %2
}
END


BEGIN Unsigned integer to floating point conversion
float f(unsigned x) {
    return x;
}
EXPECT_IR
define float @f(i32 %0) {
entry:
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %1 = load i32, ptr %x, align 4
  %2 = uitofp i32 %1 to float
  ret float %2
}
END


BEGIN Floating point to signed integer conversion
int f(float x) {
    return x;
}
EXPECT_IR
define i32 @f(float %0) {
entry:
  %x = alloca float, align 4
  store float %0, ptr %x, align 4
  %1 = load float, ptr %x, align 4
  %2 = fptosi float %1 to i32
  ret i32 %2
}
END


BEGIN Floating point to unsigned integer conversion
unsigned f(float x) {
    return x;
}
EXPECT_IR
define i32 @f(float %0) {
entry:
  %x = alloca float, align 4
  store float %0, ptr %x, align 4
  %1 = load float, ptr %x, align 4
  %2 = fptoui float %1 to i32
  ret i32 %2
}
END


BEGIN Pointer conversion
void* f(int* x) {
    return x;
}
EXPECT_IR
define ptr @f(ptr %0) {
entry:
  %x = alloca ptr, align 8
  store ptr %0, ptr %x, align 8
  %1 = load ptr, ptr %x, align 8
  ret ptr %1
}
END


BEGIN Pointer to integer conversion
short f(int* x) {
    return x;
}
EXPECT_IR
define i16 @f(ptr %0) {
entry:
  %x = alloca ptr, align 8
  store ptr %0, ptr %x, align 8
  %1 = load ptr, ptr %x, align 8
  %2 = ptrtoint ptr %1 to i16
  ret i16 %2
}
END


BEGIN Integer to pointer conversion
int* f(long x) {
    return x;
}
EXPECT_IR
define ptr @f(i32 %0) {
entry:
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %1 = load i32, ptr %x, align 4
  %2 = inttoptr i32 %1 to ptr
  ret ptr %2
}
END


BEGIN Qualified to unqualifed conversion
int f(const int x) {
    return x;
}
EXPECT_IR
define i32 @f(i32 %0) {
entry:
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %1 = load i32, ptr %x, align 4
  ret i32 %1
}
END


BEGIN Unqualified to qualifed conversion
const int f(int x) {
    return x;
}
EXPECT_IR
define i32 @f(i32 %0) {
entry:
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %1 = load i32, ptr %x, align 4
  ret i32 %1
}
END


BEGIN Qualified to qualifed conversion
volatile int f(volatile short x) {
    return x;
}
EXPECT_IR
define i32 @f(i16 %0) {
entry:
  %x = alloca i16, align 2
  store i16 %0, ptr %x, align 2
  %1 = load i16, ptr %x, align 2
  %2 = sext i16 %1 to i32
  ret i32 %2
}
END


BEGIN Pointer to qualified -> pointer to unqualifed conversion
int* f(const int* x) {
    return x;
}
EXPECT_IR
define ptr @f(ptr %0) {
entry:
  %x = alloca ptr, align 8
  store ptr %0, ptr %x, align 8
  %1 = load ptr, ptr %x, align 8
  ret ptr %1
}
END


BEGIN Pointer to unqualified -> pointer to qualifed conversion
const int* f(int* x) {
    return x;
}
EXPECT_IR
define ptr @f(ptr %0) {
entry:
  %x = alloca ptr, align 8
  store ptr %0, ptr %x, align 8
  %1 = load ptr, ptr %x, align 8
  ret ptr %1
}
END
