BEGIN Global null initialized internal variable
static int x;
EXPECT_IR
@x = internal global i32 0
END


BEGIN Global initialized internal variable
static int x = 1+1;
EXPECT_IR
@x = internal global i32 2
END


BEGIN Global initialized external variable
int x = 1+1;
EXPECT_IR
@x = global i32 2
END


BEGIN Global constant
const int x = 1+1;
EXPECT_IR
@x = constant i32 2
END


BEGIN Variable with linkage only emitted once (1)
static int x;
static int x = 1+1;
EXPECT_IR
@x = internal global i32 2
END


BEGIN Variable with linkage only emitted once (1)
static int x = 1+1;
static int x;
EXPECT_IR
@x = internal global i32 2
END


BEGIN Load parameter value
int f(int x, int y) {
    return y;
}
EXPECT_IR
define i32 @f(i32 %0, i32 %1) {
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %y = alloca i32, align 4
  store i32 %1, ptr %y, align 4
  %3 = load i32, ptr %y, align 4
  ret i32 %3
}
END


BEGIN Allocate null initialized automatic duration local variables
void f() {
    int x;
    int y;
}
EXPECT_IR
define void @f() {
  %y = alloca i32, align 4
  %x = alloca i32, align 4
  ret void
}
END


BEGIN Allocate explicitly initialized automatic duration local variable
void f() {
    int x = 7;
}
EXPECT_IR
define void @f() {
  %x = alloca i32, align 4
  store i32 7, ptr %x, align 4
  ret void
}
END


BEGIN Null initialized static duration local variable
int f() {
    static int x;
    return x;
}
EXPECT_IR
@f.x = internal global i32 0

define i32 @f() {
  %1 = load i32, ptr @f.x, align 4
  ret i32 %1
}
END


BEGIN Initialized static duration local variable
int f() {
    static int x = 1+1;
    return x;
}
EXPECT_IR
@f.x = internal global i32 2

define i32 @f() {
  %1 = load i32, ptr @f.x, align 4
  ret i32 %1
}
END


BEGIN Local constant
int f() {
    const static int x = 1+1;
    return x;
}
EXPECT_IR
@f.x = internal constant i32 2

define i32 @f() {
  %1 = load i32, ptr @f.x, align 4
  ret i32 %1
}
END


BEGIN Global array
int a[10];
EXPECT_IR
@a = global [10 x i32] zeroinitializer
END


BEGIN Local array
void f() {
    int a[10];
}
EXPECT_IR
define void @f() {
  %a = alloca [10 x i32], align 4
  ret void
}
END


BEGIN Local array variable with initializer expression
void f(int x) {
    int a[] = {x, x};
}
EXPECT_IR
define void @f(i32 %0) {
  %a = alloca [2 x i32], align 4
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %2 = getelementptr [2 x i32], ptr %a, i32 0, i64 0
  %3 = load i32, ptr %x, align 4
  store i32 %3, ptr %2, align 4
  %4 = getelementptr [2 x i32], ptr %a, i32 0, i64 1
  %5 = load i32, ptr %x, align 4
  store i32 %5, ptr %4, align 4
  ret void
}
END


BEGIN Global array variable with initializer expression
int a[] = {1, 1+1};
EXPECT_IR
@a = global [2 x i32] [i32 1, i32 2]
END


BEGIN Global initialized function pointer variable (1)
void f() {
}
void (*fp)() = &f;
EXPECT_IR
@fp = global ptr @f

define void @f() {
  ret void
}
END


BEGIN Global initialized function pointer variable (2)
void f() {
}
void (*fp)() = f;
EXPECT_IR
@fp = global ptr @f

define void @f() {
  ret void
}
END


BEGIN Global initialized function pointer variable (3)
void f() {
}
void *fp = f;
EXPECT_IR
@fp = global ptr @f

define void @f() {
  ret void
}
END


BEGIN Local variable initialized function pointer variable (1)
void f() {
}
void g() {
    void (*fp)() = &f;
}
EXPECT_IR
define void @f() {
  ret void
}

define void @g() {
  %fp = alloca ptr, align 8
  store ptr @f, ptr %fp, align 8
  ret void
}
END


BEGIN Local variable initialized function pointer variable (2)
void f() {
}
void g() {
    void (*fp)() = f;
}
EXPECT_IR
define void @f() {
  ret void
}

define void @g() {
  %fp = alloca ptr, align 8
  store ptr @f, ptr %fp, align 8
  ret void
}
END


BEGIN Global pointer variable initialized with string literal
const char* c = "\000\000f";
EXPECT_IR
@c = global ptr @const
@const = private constant [4 x i8] c"\00\00f\00"
END


BEGIN Global array variable initialized with string literal
const char c[4] = "\000\000f";
EXPECT_IR
@c = global [4 x i8] c"\00\00f\00"
END


BEGIN Global array variable initialized with smaller string literal
const char c[10] = "abc";
EXPECT_IR
@c = global [10 x i8] c"abc\00\00\00\00\00\00\00"
END


BEGIN Global pointer variable initialized with wide string literal
const unsigned short* c = L"\000\000f";
EXPECT_IR
@c = global ptr @const
@const = private constant [4 x i16] [i16 0, i16 0, i16 102, i16 0]
END


BEGIN Global array variable initialized with wide string literal
const unsigned short c[4] = L"\000\000f";
EXPECT_IR
@c = global [4 x i16] [i16 0, i16 0, i16 102, i16 0]
END


BEGIN Local pointer variable initialized with string literal
void f() {
    const char* c = "\000\000f";
}
EXPECT_IR
@const = private constant [4 x i8] c"\00\00f\00"

define void @f() {
  %c = alloca ptr, align 8
  store ptr @const, ptr %c, align 8
  ret void
}
END


BEGIN Local array variable initialized with string literal
void f() {
    const char c[] = "\000\000f";
}
EXPECT_IR
define void @f() {
  %c = alloca [4 x i8], align 1
  store [4 x i8] c"\00\00f\00", ptr %c, align 1
  ret void
}
END


BEGIN Identical string literal globals are pooled
void f() {
    const char* a = "abc";
    const char* b = "abc";
}
EXPECT_IR
@const = private constant [4 x i8] c"abc\00"

define void @f() {
  %b = alloca ptr, align 8
  %a = alloca ptr, align 8
  store ptr @const, ptr %a, align 8
  store ptr @const, ptr %b, align 8
  ret void
}
END


BEGIN Identical wide string literal globals are pooled
void f() {
    const unsigned short* a = L"abc";
    const unsigned short* b = L"abc";
}
EXPECT_IR
@const = private constant [4 x i16] [i16 97, i16 98, i16 99, i16 0]

define void @f() {
  %b = alloca ptr, align 8
  %a = alloca ptr, align 8
  store ptr @const, ptr %a, align 8
  store ptr @const, ptr %b, align 8
  ret void
}
END


BEGIN Strings of different types do not share globals
void f() {
    const char* a = "abc";
    const unsigned short* b = L"abc";
}
EXPECT_IR
@const = private constant [4 x i8] c"abc\00"
@const.1 = private constant [4 x i16] [i16 97, i16 98, i16 99, i16 0]

define void @f() {
  %b = alloca ptr, align 8
  %a = alloca ptr, align 8
  store ptr @const, ptr %a, align 8
  store ptr @const.1, ptr %b, align 8
  ret void
}
END
