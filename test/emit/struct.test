BEGIN Does not call destructor on object known to be in default state
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s;
}
EXPECT_IR
%S = type { i32 }

define void @f() {
  %s = alloca %S, align 8
  store i32 0, ptr %s, align 8
  ret void
}

define void @destructor(ptr %0) {
  ret void
}

declare void @destructor_placeholder(ptr, ptr, %S, %S)
END


BEGIN On object with non-default state, calls destructor before end of function
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s = {1};
}
EXPECT_IR
%S = type { i32 }

define void @f() {
  %s = alloca %S, align 8
  store i32 1, ptr %s, align 8
  call void @destructor(ptr %s)
  ret void
}

define void @destructor(ptr %0) {
  ret void
}

declare void @destructor_placeholder(ptr, ptr, %S, %S)
END


BEGIN Calls destructor before explicit return
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s = {1};
    return;
}
EXPECT_IR
%S = type { i32 }

define void @f() {
  %s = alloca %S, align 8
  store i32 1, ptr %s, align 8
  call void @destructor(ptr %s)
  ret void
}

define void @destructor(ptr %0) {
  ret void
}

declare void @destructor_placeholder(ptr, ptr, %S, %S)
END


BEGIN Calls destructor at end of compound statement
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    if (1) {
        S s = {1};
    }
}
EXPECT_IR
%S = type { i32 }

define void @f() {
  %s = alloca %S, align 8
  br label %if_c

if_c:                                             ; preds = %0
  store i32 1, ptr %s, align 8
  call void @destructor(ptr %s)
  br label %if_e

if_e:                                             ; preds = %if_c
  ret void
}

define void @destructor(ptr %0) {
  ret void
}

declare void @destructor_placeholder(ptr, ptr, %S, %S)
END


BEGIN Move expression resets object to default state, preventing destructor
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s = {1};
    &&s;
}
EXPECT_IR
%S = type { i32 }

define void @f() {
  %s = alloca %S, align 8
  store i32 0, ptr %s, align 8
  ret void
}

define void @destructor(ptr %0) {
  ret void
}

declare void @destructor_placeholder(ptr, ptr, %S, %S)
END


BEGIN Calls destructor after move if object is no longer be in default state
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s = {1};
    &&s;
    s.x = 2;
}
EXPECT_IR
%S = type { i32 }

define void @f() {
  %s = alloca %S, align 8
  store i32 2, ptr %s, align 8
  call void @destructor(ptr %s)
  ret void
}

define void @destructor(ptr %0) {
  ret void
}

declare void @destructor_placeholder(ptr, ptr, %S, %S)
END
