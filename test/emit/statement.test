REM ******** ForStatement ********

BEGIN Infinite while loop
void f() {
    while (1) {}
}
EXPECT_IR
define void @f() {
  br label %for_l

for_l:                                            ; preds = %for_b, %0
  br i1 true, label %for_b, label %for_e

for_b:                                            ; preds = %for_l
  call void @llvm.sideeffect()
  br label %for_l

for_e:                                            ; preds = %for_l
  ret void
}

; Function Attrs: inaccessiblememonly nocallback nofree nosync nounwind willreturn
declare void @llvm.sideeffect() #0

attributes #0 = { inaccessiblememonly nocallback nofree nosync nounwind willreturn }
END


BEGIN Infinite for loop
void f() {
    for (;;) {}
}
EXPECT_IR
define void @f() {
  br label %for_l

for_l:                                            ; preds = %for_l, %0
  call void @llvm.sideeffect()
  br label %for_l

for_e:                                            ; No predecessors!
  ret void
}

; Function Attrs: inaccessiblememonly nocallback nofree nosync nounwind willreturn
declare void @llvm.sideeffect() #0

attributes #0 = { inaccessiblememonly nocallback nofree nosync nounwind willreturn }
END


BEGIN For integer range
void f() {
    unsigned i;
    for (i = 1; i < 10; ++i) {}
}
EXPECT_IR
define void @f() {
  %i = alloca i32, align 4
  store i32 1, ptr %i, align 4
  br label %for_l

for_l:                                            ; preds = %for_i, %0
  %1 = load i32, ptr %i, align 4
  %2 = icmp ult i32 %1, 10
  br i1 %2, label %for_b, label %for_e

for_b:                                            ; preds = %for_l
  br label %for_i

for_i:                                            ; preds = %for_b
  %3 = load i32, ptr %i, align 4
  %4 = add i32 %3, 1
  store i32 %4, ptr %i, align 4
  br label %for_l

for_e:                                            ; preds = %for_l
  ret void
}
END


BEGIN For integer range with internal declaration
void f() {
    for (unsigned i = 1; i < 10; ++i) {}
}
EXPECT_IR
define void @f() {
  %i = alloca i32, align 4
  store i32 1, ptr %i, align 4
  br label %for_l

for_l:                                            ; preds = %for_i, %0
  %1 = load i32, ptr %i, align 4
  %2 = icmp ult i32 %1, 10
  br i1 %2, label %for_b, label %for_e

for_b:                                            ; preds = %for_l
  br label %for_i

for_i:                                            ; preds = %for_b
  %3 = load i32, ptr %i, align 4
  %4 = add i32 %3, 1
  store i32 %4, ptr %i, align 4
  br label %for_l

for_e:                                            ; preds = %for_l
  ret void
}
END


BEGIN Break for loop
void f() {
    for (int i = 0; i < 10; ++i) {
        break;
    }
}
EXPECT_IR
define void @f() {
  %i = alloca i32, align 4
  store i32 0, ptr %i, align 4
  br label %for_l

for_l:                                            ; preds = %for_i, %0
  %1 = load i32, ptr %i, align 4
  %2 = icmp slt i32 %1, 10
  br i1 %2, label %for_b, label %for_e

for_b:                                            ; preds = %for_l
  br label %for_e

for_i:                                            ; No predecessors!
  %3 = load i32, ptr %i, align 4
  %4 = add i32 %3, 1
  store i32 %4, ptr %i, align 4
  br label %for_l

for_e:                                            ; preds = %for_b, %for_l
  ret void
}
END


BEGIN Continue for loop
void f() {
    for (int i = 0; i < 10; ++i) {
        continue;
    }
}
EXPECT_IR
define void @f() {
  %i = alloca i32, align 4
  store i32 0, ptr %i, align 4
  br label %for_l

for_l:                                            ; preds = %for_i, %0
  %1 = load i32, ptr %i, align 4
  %2 = icmp slt i32 %1, 10
  br i1 %2, label %for_b, label %for_e

for_b:                                            ; preds = %for_l
  br label %for_i

for_i:                                            ; preds = %for_b
  %3 = load i32, ptr %i, align 4
  %4 = add i32 %3, 1
  store i32 %4, ptr %i, align 4
  br label %for_l

for_e:                                            ; preds = %for_l
  ret void
}
END


BEGIN Break in for loop causes destructors to be called
struct S {
    int x;
    void destructor(S&);
};
void f() {
    for (int i = 0; i < 10; ++i) {
        S s = {1};
        break;
    }
}
EXPECT_IR
%S = type { i32 }

define void @f() {
  %s = alloca %S, align 8
  %i = alloca i32, align 4
  store i32 0, ptr %i, align 4
  br label %for_l

for_l:                                            ; preds = %for_i, %0
  %1 = load i32, ptr %i, align 4
  %2 = icmp slt i32 %1, 10
  br i1 %2, label %for_b, label %for_e

for_b:                                            ; preds = %for_l
  %x = getelementptr inbounds %S, ptr %s, i32 0, i32 0
  store i32 1, ptr %x, align 4
  call void @destructor_wrapper(ptr %s)
  br label %for_e

for_i:                                            ; No predecessors!
  %3 = load i32, ptr %i, align 4
  %4 = add i32 %3, 1
  store i32 %4, ptr %i, align 4
  br label %for_l

for_e:                                            ; preds = %for_b, %for_l
  ret void
}

declare void @destructor(ptr nocapture)

declare void @destructor_wrapper(ptr)
END


REM ******** GoToStatement ********

BEGIN Goto prior label
void f() {
target:
    goto target;
}
EXPECT_IR
define void @f() {
  br label %target

target:                                           ; preds = %target, %0
  br label %target
}
END


BEGIN Goto following label
void f() {
    goto target;
target:
    return;
}
EXPECT_IR
define void @f() {
  br label %target

target:                                           ; preds = %0
  ret void
}
END


BEGIN Goto calls destructors before branching (1)
struct S {
    int x;
    void destructor(S&);
};
void f() {
    S t = {1};
    {
        S s = {1};
        goto target;
    }
    {
target:
        return;
    }
}
EXPECT_IR
%S = type { i32 }

define void @f() {
  %s = alloca %S, align 8
  %t = alloca %S, align 8
  %x = getelementptr inbounds %S, ptr %t, i32 0, i32 0
  store i32 1, ptr %x, align 4
  %x1 = getelementptr inbounds %S, ptr %s, i32 0, i32 0
  store i32 1, ptr %x1, align 4
  call void @destructor_wrapper(ptr %s)
  br label %target

target:                                           ; preds = %0
  call void @destructor_wrapper(ptr %t)
  ret void
}

declare void @destructor(ptr nocapture)

declare void @destructor_wrapper(ptr)
END


BEGIN Goto calls destructors before branching (2)
struct S {
    int x;
    void destructor(S&);
};
void f() {
    S t = {1};
    {
target:
        t.x = 2;
    }
    {
        S s = {1};
        goto target;
    }
}
EXPECT_IR
%S = type { i32 }

define void @f() {
  %s = alloca %S, align 8
  %t = alloca %S, align 8
  %x = getelementptr inbounds %S, ptr %t, i32 0, i32 0
  store i32 1, ptr %x, align 4
  br label %target

target:                                           ; preds = %target, %0
  %x1 = getelementptr inbounds %S, ptr %t, i32 0, i32 0
  store i32 2, ptr %x1, align 4
  %x2 = getelementptr inbounds %S, ptr %s, i32 0, i32 0
  store i32 1, ptr %x2, align 4
  call void @destructor_wrapper(ptr %s)
  br label %target
}

declare void @destructor(ptr nocapture)

declare void @destructor_wrapper(ptr)
END


BEGIN Error on break outside appropriate construct
void f() {
    break;
}
EXPECT_MESSAGE
:2:5: error 'break' statement not in loop or switch statement
END


BEGIN Error on continue outside appropriate construct
void f() {
    continue;
}
EXPECT_MESSAGE
:2:5: error 'continue' statement not in loop or switch statement
END


REM ******** IfElseStatement ********

BEGIN If statement
void f(int c) {
    if (c) {}
}
EXPECT_IR
define void @f(i32 %0) {
  %c = alloca i32, align 4
  store i32 %0, ptr %c, align 4
  %2 = load i32, ptr %c, align 4
  %3 = trunc i32 %2 to i1
  br i1 %3, label %if_c, label %if_e

if_c:                                             ; preds = %1
  br label %if_e

if_e:                                             ; preds = %if_c, %1
  ret void
}
END


BEGIN If-else statement
void f(int c) {
    if (c) {}
    else {}
}
EXPECT_IR
define void @f(i32 %0) {
  %c = alloca i32, align 4
  store i32 %0, ptr %c, align 4
  %2 = load i32, ptr %c, align 4
  %3 = trunc i32 %2 to i1
  br i1 %3, label %if_c, label %if_a

if_c:                                             ; preds = %1
  br label %if_e

if_a:                                             ; preds = %1
  br label %if_e

if_e:                                             ; preds = %if_a, %if_c
  ret void
}
END



REM ******** ReturnStatement ********

BEGIN Emit explicit return void
void f() {
    return;
}
EXPECT_IR
define void @f() {
  ret void
}
END


BEGIN Emit implicit return void
void f() {
}
EXPECT_IR
define void @f() {
  ret void
}
END


BEGIN Emit return constant
int f() {
    return 0;
}
EXPECT_IR
define i32 @f() {
  ret i32 0
}
END


BEGIN Emit implicit return null value (1)
int f() {
}
EXPECT_IR
define i32 @f() {
  ret i32 0
}
END


BEGIN Emit implicit return null value (2)
struct S { int x; };
S f() {
}
EXPECT_IR
%S = type { i32 }

define %S @f() {
  ret %S zeroinitializer
}
END


BEGIN Return void value from void function
void g() {}
void f() {
    return g();
}
END


BEGIN Error on return value in void function
void f() {
    return 1;
}
EXPECT_MESSAGE
:2:12: error void function 'f' should not return a value
:1:6: ... see return type of function 'f'
END


BEGIN Error on missing return value in non-void function
int f() {
    return;
}
EXPECT_MESSAGE
:2:5: error non-void function 'f' should return a value
:1:5: ... see return type of function 'f'
END


BEGIN Return statement causes destructors in all scopes to be called
struct S {
    int x;
    void destructor(S&) {}
};
int who_knows();
void f(S s) {
    {
        S t = {1};
        if (who_knows()) return;
    }
}
EXPECT_IR
%S = type { i32 }

declare i32 @who_knows()

define void @f(%S %0) {
  %t = alloca %S, align 8
  %s = alloca %S, align 8
  store %S %0, ptr %s, align 4
  %x = getelementptr inbounds %S, ptr %t, i32 0, i32 0
  store i32 1, ptr %x, align 4
  %2 = call i32 @who_knows()
  %3 = trunc i32 %2 to i1
  br i1 %3, label %if_c, label %if_e

if_c:                                             ; preds = %1
  call void @destructor_wrapper(ptr %t)
  call void @destructor_wrapper(ptr %s)
  ret void

if_e:                                             ; preds = %1
  call void @destructor_wrapper(ptr %t)
  call void @destructor_wrapper(ptr %s)
  ret void
}

define void @destructor(ptr nocapture %0) {
  ret void
}

declare void @destructor_wrapper(ptr)
END


REM ******** SwitchStatement ********

BEGIN Switch with default
int f(int x) {
    switch (x) {
        default:
            return 21;
        case 7:
            x = 3;
            // falls through
        case 1+1:
            return 2;
        case 3:
            break;
    }
}
EXPECT_IR
define i32 @f(i32 %0) {
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %2 = load i32, ptr %x, align 4
  switch i32 %2, label %6 [
    i32 7, label %4
    i32 2, label %5
    i32 3, label %3
  ]

3:                                                ; preds = %1
  br label %7

4:                                                ; preds = %1
  store i32 3, ptr %x, align 4
  br label %5

5:                                                ; preds = %4, %1
  ret i32 2

6:                                                ; preds = %1
  ret i32 21

7:                                                ; preds = %3
  ret i32 0
}
END

BEGIN Switch without default
int f(int x) {
    switch (x) {
        case 7:
            x = 3;
            // falls through
        case 1+1:
            return 2;
        case 3:
            break;
    }
}
EXPECT_IR
define i32 @f(i32 %0) {
  %x = alloca i32, align 4
  store i32 %0, ptr %x, align 4
  %2 = load i32, ptr %x, align 4
  switch i32 %2, label %6 [
    i32 7, label %4
    i32 2, label %5
    i32 3, label %3
  ]

3:                                                ; preds = %1
  br label %6

4:                                                ; preds = %1
  store i32 3, ptr %x, align 4
  br label %5

5:                                                ; preds = %4, %1
  ret i32 2

6:                                                ; preds = %3, %1
  ret i32 0
}
END


BEGIN Case expressions must be integer
int f(int x) {
    switch (x) {
        case 1.5:
            break;
    }
}
EXPECT_MESSAGE
:3:14: error case must have integer constant expression
END
