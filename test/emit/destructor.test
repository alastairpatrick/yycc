BEGIN Does not call destructor on object known to be in default state
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s;
}
EXPECT_IR
%S = type { i32 }

define void @f() local_unnamed_addr {
  %s = alloca %S, align 8
  store i32 0, ptr %s, align 8
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define void @destructor(ptr nocapture readnone %0) #0 {
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind readnone willreturn }
END


BEGIN On object with non-default state, calls destructor before end of function
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s = {1};
}
EXPECT_IR
%S = type { i32 }

define void @f() local_unnamed_addr {
  %s = alloca %S, align 8
  store i32 1, ptr %s, align 8
  call void @destructor(ptr %s)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define void @destructor(ptr nocapture readnone %0) #0 {
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind readnone willreturn }
END


BEGIN Calls destructor before explicit return
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s = {1};
    return;
}
EXPECT_IR
%S = type { i32 }

define void @f() local_unnamed_addr {
  %s = alloca %S, align 8
  store i32 1, ptr %s, align 8
  call void @destructor(ptr %s)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define void @destructor(ptr nocapture readnone %0) #0 {
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind readnone willreturn }
END


BEGIN Calls destructor at end of compound statement
struct S {
    int x;
    void destructor(S&) {}
};
int g();
void f() {
    if (g()) {
        S s = {1};
    }
}
EXPECT_IR
%S = type { i32 }

declare i32 @g() local_unnamed_addr

define void @f() local_unnamed_addr {
  %s = alloca %S, align 8
  %1 = tail call i32 @g()
  %2 = and i32 %1, 1
  %.not = icmp eq i32 %2, 0
  br i1 %.not, label %if_e, label %if_c

if_c:                                             ; preds = %0
  store i32 1, ptr %s, align 8
  call void @destructor(ptr %s)
  br label %if_e

if_e:                                             ; preds = %if_c, %0
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define void @destructor(ptr nocapture readnone %0) #0 {
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind readnone willreturn }
END


BEGIN Move expression resets object to default state, preventing destructor
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s = {1};
    &&s;
}
EXPECT_IR
%S = type { i32 }

define void @f() local_unnamed_addr {
  %1 = alloca %S, align 8
  %s = alloca %S, align 8
  store i32 0, ptr %s, align 8
  store i32 1, ptr %1, align 8
  call void @destructor(ptr %1)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define void @destructor(ptr nocapture readnone %0) #0 {
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind readnone willreturn }
END


BEGIN Calls destructor after move if object is no longer in default state
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s = {1};
    &&s;
    s.x = 2;
}
EXPECT_IR
%S = type { i32 }

define void @f() local_unnamed_addr {
  %1 = alloca %S, align 8
  %s = alloca %S, align 8
  store i32 1, ptr %1, align 8
  call void @destructor(ptr %1)
  store i32 2, ptr %s, align 8
  call void @destructor(ptr %s)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define void @destructor(ptr nocapture readnone %0) #0 {
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind readnone willreturn }
END


BEGIN Move expression in initializer expression
struct S {
    int x;
    void destructor(S&) {}
};
void f() {
    S s = {1};
    S t = &&s;  // now t should be destroyed but not s. TODO the temporary should not be destroyed because it initialized t
}
EXPECT_IR
%S = type { i32 }

define void @f() local_unnamed_addr {
  %1 = alloca %S, align 8
  %t = alloca %S, align 8
  %s = alloca %S, align 8
  store i32 0, ptr %s, align 8
  store i32 1, ptr %1, align 8
  store i32 1, ptr %t, align 8
  call void @destructor(ptr %1)
  call void @destructor(ptr %t)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define void @destructor(ptr nocapture readnone %0) #0 {
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind readnone willreturn }
END


BEGIN Object destructor is called because an external function might have set it to non-default state
struct S {
    int x;
    void destructor(S&) {}
};
void e(S&);
void f() {
    S s;
    e(s);
}
EXPECT_IR
%S = type { i32 }

declare void @e(ptr) local_unnamed_addr

define void @f() local_unnamed_addr {
  %s = alloca %S, align 8
  store i32 0, ptr %s, align 8
  call void @e(ptr nonnull %s)
  %.fca.0.load = load i32, ptr %s, align 8
  %.fca.0.insert = insertvalue %S poison, i32 %.fca.0.load, 0
  call void @destructor(ptr %s)
  ret void
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define void @destructor(ptr nocapture readnone %0) #0 {
  ret void
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind readnone willreturn }
END


