BEGIN Function parameters of function type are adjusted to pointer
int foo(int bar(void));
EXPECT_AST
[["fun", "E", ["F", "Si", ["P", ["F", "Si"]]], "foo"]]


BEGIN Function parameters of array type are adjusted to pointer (1)
int foo(int x[]);
EXPECT_AST
[["fun", "E", ["F", "Si", ["P", "Si"]], "foo"]]


BEGIN Function parameters of array type are adjusted to pointer (2)
int foo(int x[2]);
EXPECT_AST
[["fun", "E", ["F", "Si", ["P", "Si"]], "foo"]]


BEGIN Function parameters of array type are adjusted to pointer (3)
int foo(int x[2][3]);
EXPECT_AST
[["fun","E",["F","Si",["P",["A","Si",3]]],"foo"]]


BEGIN Qualified array type parameter
int foo(int x[const volatile restrict 1]);
EXPECT_AST
[["fun","E",["F","Si",["Qcrv",["P","Si"]]],"foo"]]


BEGIN Error on qualified array type parameter that is not outer-most
int foo(int x[2][const volatile restrict 3]);
EXPECT_MESSAGE
:1:18: error unexpected token 'const'
EXPECT_AST
[["fun","E",["F","Si",["P",["A","Si"]]],"foo"]]


BEGIN Static array type parameter
int foo(int x[static 1]);
EXPECT_AST
[["fun","E",["F","Si",["P","Si"]],"foo"]]


BEGIN Function parameters of typedef array type are adjusted to pointer
#type T
int foo(T x);
typedef int T[];
EXPECT_GLOBALS
[["typedef",["A","Si"],"T"]
,["fun","E",["F","Si",["P","Si"]],"foo"]]


BEGIN typeof parameter
void foo(int x, typeof(x) y);
EXPECT_AST
[["fun","E",["F","V","Si","Si"],"foo"]]


BEGIN Extern storage class prevents inline definition (1)
extern inline void foo();
EXPECT_GLOBALS
[["fun","E",["F","V"],"foo"]]


BEGIN Extern storage class prevents inline definition (2)
extern void foo();
inline void foo();
EXPECT_GLOBALS
[["fun","E",["F","V"],"foo"]]


BEGIN Extern storage class prevents inline definition (3)
inline void foo();
extern void foo();
EXPECT_GLOBALS
[["fun","E",["F","V"],"foo"]]


BEGIN Function definition with function declaration (1)
static void foo(int);
void foo(int x) {
}
EXPECT_GLOBALS
[["fun","I",["F","V","Si"],"foo",["x"],["block",[]]]]


BEGIN Function definition with function declaration (2)
void foo(int x) {
}
extern void foo(int);
EXPECT_GLOBALS
[["fun","E",["F","V","Si"],"foo",["x"],["block",[]]]]


BEGIN Function initially declared with a function-typed typedef
typedef void F(int x);
F foo;
void foo(int x) {
}
EXPECT_GLOBALS
[["typedef",["F","V","Si"],"F"]
,["fun","E",["F","V","Si"],"foo",["x"],["block",[]]]]


BEGIN Enitity declared like both a variable and function
typedef void F(int x);
F foo = 7;
void foo(int x) {
}
EXPECT_MESSAGE
:3:6: error redefinition of function 'foo' with different kind of identifier...
:2:3: ...see other
END


BEGIN Function declared only in variable like way
typedef void F(int x);
F foo;
F foo;
EXPECT_GLOBALS
[["typedef",["F","V","Si"],"F"],["fun","E",["F","V","Si"],"foo"]]


BEGIN Error on function redefinition
void foo(int x) {
}
void foo(int x) {
}
EXPECT_MESSAGE
:3:6: error redefinition of function 'foo'...
:1:6: ...see other
END


BEGIN Block scope extern storage class
void foo(int);
{
    extern void foo(int);
}
EXPECT_AST
[["fun","E",["F","V","Si"],"foo"],["block",[
    ["fun","E",["F","V","Si"],"foo"]]
]]


BEGIN Redeclare variable with internal linkage at block scope.
static int x;
void foo(int);
{
    typedef int x;
    {
        extern int x, y;
        x * y;  // Multiplies rather than declaring variable "y" of type "int*"
    }
}
EXPECT_AST
[["var","IS","Si","x"]
,["fun","E",["F","V","Si"],"foo"],["block",[
    ["typedef","Si","x"]
    ,["block",[
        [["var","ES","Si","x"]
        ,["var","ES","Si","y"]]
        ,["*","Nx","Ny"]]
    ]]
]]


BEGIN Resolves type declarators declared in function prototype scope
void f(enum E { A } a, enum E { B } b) {
}
EXPECT_MESSAGE
:1:33: error enum constant 'B'...
:1:8: ...missing from other definition
END