BEGIN Outside namespace, unqualified identifier
int a;
EXPECT_AST
[["var","ES","Si","a"]]

BEGIN Outside namespace, :: prefixed identifier
int ::a;
EXPECT_AST
[["var","ES","Si","a"]]

BEGIN Outside namespace, qualified identifier
int a::b::c;
EXPECT_AST
[["var","ES","Si","a::b::c"]]

BEGIN Outside namespace, :: prefixed and qualified identifier
int ::a::b::c;
EXPECT_AST
[["var","ES","Si","a::b::c"]]



BEGIN In namespace, :: prefixed identifier is always relative to root namespace
#namespace X::Y
int ::a;
EXPECT_AST
[["var","ES","Si","a"]]


BEGIN In namespace, :: prefixed identifier is always relative to root namespace (1)
#namespace X::Y
int ::X::a;
EXPECT_AST
[["var","ES","Si","X::a"]]


BEGIN In namespace, :: prefixed identifier is always relative to root namespace (2)
#namespace X::Y
int ::Y::a;
EXPECT_AST
[["var","ES","Si","Y::a"]]



BEGIN In namespace, unqualified identifier is always appended to namespace (1)
#namespace X::Y
int a;
EXPECT_AST
[["var","ES","Si","X::Y::a"]]


BEGIN In namespace, unqualified identifier is always appended to namespace (2)
#namespace X::Y
int X;
EXPECT_AST
[["var","ES","Si","X"]]


BEGIN In namespace, unqualified identifier is always appended to namespace (3)
#namespace X::Y
int Y;
EXPECT_AST
[["var","ES","Si","X::Y"]]


BEGIN In namespace, qualified identifier with no leading :: and not matching handle is appended to namespace
#namespace X::Y
int Z::a;
EXPECT_AST
[["var","ES","Si","X::Y::Z::a"]]


BEGIN In namespace, qualified identifier with no leading :: and matching handle is relative to handle (1)
#namespace X::Y
int X::a;
EXPECT_AST
[["var","ES","Si","X::a"]]


BEGIN In namespace, qualified identifier with no leading :: and matching handle is relative to handle (2)
#namespace X::Y
int Y::a;
EXPECT_AST
[["var","ES","Si","X::Y::a"]]


BEGIN Reset namespace
#namespace X::Y
#namespace
int a;
EXPECT_AST
[["var","ES","Si","a"]]


BEGIN Namespace may be :: prefixed
#namespace ::X::Y
int a;
EXPECT_AST
[["var","ES","Si","X::Y::a"]]


BEGIN Error if namespace token is not identifier
#namespace 7
EXPECT_MESSAGE
:1:12: error unexpected '7' token in directive
END


BEGIN Substitute unqualified identifier according to using directive (1)
#using std::sort
int std::sort;
int x = sort;
PARSE
EXPECT_AST
[["var","ES","Si","std::sort"],["var","ES","Si","x","Nstd::sort"]]


BEGIN Substitute unqualified identifier according to using directive (2)
#using ::std::sort
int std::sort;
int x = sort;
PARSE
EXPECT_AST
[["var","ES","Si","std::sort"],["var","ES","Si","x","Nstd::sort"]]


BEGIN Substitute unqualified identifier according to using directive (3)
#using std::exp::sort
int std::exp::sort;
int x = sort;
PARSE
EXPECT_AST
[["var","ES","Si","std::exp::sort"],["var","ES","Si","x","Nstd::exp::sort"]]


BEGIN Substitute unqualified identifier according to using equals directive (1)
#using std_sort = std::exp::sort
int std::exp::sort;
int x = std_sort;
PARSE
EXPECT_AST
[["var","ES","Si","std::exp::sort"],["var","ES","Si","x","Nstd::exp::sort"]]


BEGIN First token of using missing
#using
EXPECT_MESSAGE
:1:7: error expected identifier
END


BEGIN First token of using directive not an identifier
#using 7
EXPECT_MESSAGE
:1:8: error unexpected '7' token in directive
END


BEGIN Unexpected punctuator instead of equals in using directive
#using std_sort : std::exp::sort
EXPECT_MESSAGE
:1:17: error unexpected ':' token in directive
END


BEGIN Third token of using directive not an identifier
#using sort = 7
EXPECT_MESSAGE
:1:15: error unexpected '7' token in directive
END



BEGIN Using directive parameter is itself evaluated as an identifier
#using ns = std
#using sort = ns::sort
int std::sort;
int x = sort;
PARSE
EXPECT_AST
[["var","ES","Si","std::sort"],["var","ES","Si","x","Nstd::sort"]]



BEGIN Namespace does not affect identifiers declared at block scope
#namespace X::Y::Z
void f() {
    int x;
}
PARSE
EXPECT_AST
[["fun","E",["F","V"],"X::Y::Z::f",[],["block",[["var","","Si","x"]]]]]


BEGIN Namespace does not affect struct members
#namespace X::Y::Z
struct S {
    int x;
} z;
EXPECT_AST
[["var","ES",["STRUCT",[["x","Si"]]],"X::Y::Z::z"]]


BEGIN Namespace affects enum constants
#namespace X::Y::Z
enum E {
    A,
} z;
EXPECT_AST
[["var","ES",["ENUM",[["ec","X::Y::Z::A"]]],"X::Y::Z::z"]]


BEGIN Namespace does not affects enum constants with block scope
#namespace X::Y::Z
void f() {
    enum E {
        A,
    } z;
}
PARSE
EXPECT_AST
[["fun","E",["F","V"],"X::Y::Z::f",[],["block",[
    ["var","",["ENUM",[["ec","A"]]],"z"]
]]]]


BEGIN Can alias keywords with using directive
#using my_int = int
my_int x;
EXPECT_AST
[["var","ES","Si","x"]]


BEGIN Can alias keywords with using directive within namespace
#namespace X::Y::Z
#using my_int = int
my_int x;
EXPECT_AST
[["var","ES","Si","X::Y::Z::x"]]


BEGIN Error on undefined identifier reports file scope identifier rather than lexer text (1)
#using A = foo
A x;
PARSE
EXPECT_MESSAGE
:2:1: error type 'A' (aka 'foo') undefined
END


BEGIN Error on undefined identifier reports file scope identifier rather than lexer text (2)
#using A = foo
void f() {
    A;
}
PARSE
EXPECT_MESSAGE
:3:5: error identifier 'A' (aka 'foo') undeclared
END


BEGIN Enum constants may have qualified identifiers
enum E {
    E::A,
    E::B,
} z;
EXPECT_AST
[["var","ES",["ENUM",[["ec","E::A"],["ec","E::B"]]],"z"]]


BEGIN Qualified identifier of nested structure added to enclosing scope (1)
struct S {
    struct T {};
};
S::T x;
PARSE
EXPECT_GLOBALS
[["typedef",["STRUCT",[["",["STRUCT",[]]]]],"S"]
,["typedef",["STRUCT",[]],"S::T"]
,["var","ES",["STRUCT",[]],"x"]]


BEGIN Qualified identifier of nested structure added to enclosing scope (2)
void f() {
    struct S {
        struct T {};
    };
    S::T x;
}
PARSE
EXPECT_AST
[["fun","E",["F","V"],"f",[],["block",[
    []
   ,["var","",["STRUCT",[]],"x"]
]]]]


BEGIN Qualified identifier of nested structure added to enclosing scope (3)
struct S {
    struct T {
        struct U {
        };
    };
    S::T::U x;
    T::U y;
};
S::T::U z;
PARSE
EXPECT_AST
[[],["var","ES",["STRUCT",[]],"z"]]


BEGIN Qualified identifier of nested structure added to enclosing scope (4)
struct S {
    struct T;
};
S::T* z;
PARSE
EXPECT_AST
[[],["var","ES",["P",["STRUCT",["?"]]],"z"]]


BEGIN Qualified identifier of nested structure added to enclosing scope (5)
struct S {
    struct T {
        struct U {
        };
    };
    U y;
};
PARSE
EXPECT_MESSAGE
:6:5: error type 'U' undefined
END


BEGIN Qualified identifier of nested enum added to enclosing scope
void f() {
    struct S {
        enum E { E::A };
    };
    S::E x = S::E::A;
}
PARSE
EXPECT_AST
[["fun","E",["F","V"],"f",[],["block",[
    []
   ,["var","",["ENUM",[["ec","E::A"]]],"x","NS::E::A"]
]]]]
